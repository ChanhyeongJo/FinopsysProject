# -*- coding: utf-8 -*-
"""알고리즘 과정 및 일부 시각화

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i-gBDZLjiaKkLoJmaVfYM8Uk4uhpvjfo
"""

# 경고 메시지 제거
import warnings
warnings.filterwarnings('ignore')

# Library import
import numpy as np
import pandas as pd
from joblib import Parallel, delayed
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import csr_matrix

# 시각화 library import
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import font_manager

# 한글폰트 오류 방지 설정
!apt-get update -qq
!apt-get install -qq fonts-nanum > /dev/null
font_fname = '/usr/share/fonts/truetype/nanum/NanumGothic.ttf'
font_family = font_manager.FontProperties(fname=font_fname).get_name()
plt.rcParams['font.family'] = font_family

# 데이터 로드
#df_회원 = pd.read_csv('cluster_final.csv')
df_상품 = pd.read_csv('df_상품_442.csv')

#data = pd.read_csv('user_final_real.csv')

df_회원 = pd.read_csv('cluster_final.csv')

df_상품.head()

df_회원.head()

df_회원.info()

df = pd.read_csv('df_회원_필요칼럼.csv')

df.head()

df.shape

# 가입금액 전처리 함수
def process_join_amount(value):
    try:
        if pd.isna(value) or "제한없음" in value or "0원" in value:
            return 0
        if "백" in value:
            return float(value.replace("백", "").strip()) * 100
        if "천" in value:
            return float(value.replace("천", "").strip()) * 1000
        if "만원" in value:
            return float(value.replace("만원", "").split("~")[0].strip()) * 10000
        return float(value)
    except Exception:
        return 0

# 추천 점수 계산 함수
def calculate_recommendation_score(member, product, weight_factors):
    life_stage_match = int(str(member['Life_Stage']) in str(product['가입대상고객_조건'])) * weight_factors['life_stage']
    join_amount_ratio = (product['processed_가입금액'] / (member['총이용금액'] + 1e-6)) * weight_factors['join_amount']
    delinquency_score = (1 - member['연체비율']) * weight_factors['delinquency']
    return life_stage_match + join_amount_ratio + delinquency_score

# 회원별 상품 추천 함수
def recommend_for_member(member, products, weight_factors, top_n=5):
    if products.empty:
        return []
    products['매칭점수'] = products.apply(lambda product: calculate_recommendation_score(member, product, weight_factors), axis=1)
    return products.nlargest(top_n, '매칭점수')['상품명'].tolist()

# 병렬 처리 추천 실행
def recommend_parallel(members, products, weight_factors, n_jobs=4, top_n=5):
    results = Parallel(n_jobs=n_jobs, backend='threading')(
        delayed(recommend_for_member)(member, products, weight_factors, top_n) for _, member in members.iterrows()
    )
    return pd.DataFrame({"회원인덱스": members.index, "추천상품": results})

# 실행 함수
def execute_recommendation(df_회원, df_상품, sample_size=1000, n_jobs=8, top_n=5):
    df_회원['Life_Stage'] = df_회원['Life_Stage'].astype(str)
    df_상품['가입대상고객_조건'] = df_상품['가입대상고객_조건'].astype(str)

    df_회원_sample = df_회원.sample(n=sample_size, random_state=42)
    df_상품['processed_가입금액'] = df_상품['가입금액'].apply(process_join_amount)

    weight_factors = {"life_stage": 0.5, "join_amount": 0.3, "delinquency": 0.2}
    df_추천결과 = recommend_parallel(df_회원_sample, df_상품, weight_factors, n_jobs=n_jobs, top_n=top_n)

    return df_추천결과

# 추천 실행 및 결과 출력
df_추천결과 = execute_recommendation(df_회원, df_상품, sample_size=1000, n_jobs=4, top_n=5)
df_추천결과

df_추천결과.to_csv('df_추천결과_1000.csv', index=False)

def recommend_for_member_with_filtering(member, products, weight_factors, top_n=5):
    """
    회원별로 추천 가능한 상품을 필터링하고, 추천 상품을 반환하며 필터링 과정의 정보를 기록.
    """
    if products.empty:
        return [], 0, 0  # 추천 가능한 상품이 없음

    # 상품 필터링: Life Stage가 맞는 상품만 남김
    filtered_products = products[products['가입대상고객_조건'].str.contains(str(member['Life_Stage']), na=False)]

    # 필터링 결과
    filtered_count = len(filtered_products)
    total_count = len(products)

    if filtered_products.empty:
        return [], total_count - filtered_count, filtered_count  # 남은 추천 상품 없음

    # 매칭 점수 계산
    filtered_products['매칭점수'] = filtered_products.apply(
        lambda product: calculate_recommendation_score(member, product, weight_factors), axis=1
    )
    recommended = filtered_products.nlargest(top_n, '매칭점수')['상품명'].tolist()

    return recommended, total_count - filtered_count, filtered_count

def recommend_parallel_with_filtering(members, products, weight_factors, n_jobs=4, top_n=5):
    """
    병렬 처리로 모든 회원에 대해 추천 상품과 필터링 정보를 반환.
    """
    results = Parallel(n_jobs=n_jobs, backend='threading')(
        delayed(recommend_for_member_with_filtering)(member, products, weight_factors, top_n) for _, member in members.iterrows()
    )

    recommended_products = [result[0] for result in results]
    filtered_counts = [result[1] for result in results]
    remaining_counts = [result[2] for result in results]

    return pd.DataFrame({
        "회원인덱스": members.index,
        "추천상품": recommended_products,
        "필터링된상품수": filtered_counts,
        "남아있는상품수": remaining_counts
    })

def execute_recommendation_with_filtering(df_회원, df_상품, sample_size=1000, n_jobs=8, top_n=5):
    df_회원['Life_Stage'] = df_회원['Life_Stage'].astype(str)
    df_상품['가입대상고객_조건'] = df_상품['가입대상고객_조건'].astype(str)

    df_회원_sample = df_회원.sample(n=sample_size, random_state=42)
    df_상품['processed_가입금액'] = df_상품['가입금액'].apply(process_join_amount)

    weight_factors = {"life_stage": 0.5, "join_amount": 0.3, "delinquency": 0.2}
    df_추천결과 = recommend_parallel_with_filtering(df_회원_sample, df_상품, weight_factors, n_jobs=n_jobs, top_n=top_n)

    return df_추천결과

# 실행 및 결과 확인
df_추천결과_with_filtering = execute_recommendation_with_filtering(df_회원, df_상품, sample_size=1000, n_jobs=4, top_n=5)

# 전체 필터링 요약
unique_products = df_상품['상품명'].nunique()  # 고유 상품 개수
total_filtered = df_추천결과_with_filtering['필터링된상품수'].sum()
total_remaining = df_추천결과_with_filtering['남아있는상품수'].sum()

# 상세 결과 확인
df_추천결과_with_filtering.head()

# 상품 특정화

# 모든 추천상품 열에서 남아있는 상품 리스트 추출
all_remaining_products = df_추천결과_with_filtering['추천상품'].explode()

# 남아있는 상품 중복 제거 (고유 상품 리스트)
unique_remaining_products = all_remaining_products.dropna().unique()

# 원본 상품 데이터에서 해당 상품의 상세 정보 가져오기
remaining_product_details = df_상품[df_상품['상품명'].isin(unique_remaining_products)]

# 결과 출력
print(f"남아있는 상품의 고유 개수: {len(unique_remaining_products)}")
print(f"남아있는 상품 상세 정보:")
remaining_product_details

# 31개의 상품 추천된 이유

# 가입금액:

# 대부분의 상품은 "제한없음"으로 표시되며, processed_가입금액으로 변환된 값은 0으로 처리되었습니다.
# 일부 항목은 최소 가입금액(예: 300만 원)을 포함하고 있습니다.
# 기본 금리:

# 평균 금리는 약 2.57%이며, 최대 5%까지 존재합니다.
# 계약 기간:

# 다양한 계약 기간이 존재하며, 가장 흔한 것은 "12개월 이상 ~ 24개월 미만"입니다.
# 가입대상 고객 조건:

# 특정 연령대(예: 만 19세~34세)나 조건(예: 무주택 세대주)에 해당하는 상품이 다수를 차지합니다.

import pandas as pd

# 추천 알고리즘 함수
def recommend_products(member_info, products, top_n=5):
    # Step 1: 회원 정보 추출
    life_stage = str(member_info['Life_Stage'])  # 숫자를 문자열로 변환
    total_amount = float(member_info['총이용금액'])
    delinquency_ratio = float(member_info['연체비율'])

    # Step 2: 상품 데이터 필터링
    filtered_products = products[products['가입대상고객_조건'].str.contains(life_stage, na=False)]

    # Step 3: 매칭 점수 계산
    def calculate_score(product):
        life_stage_match = 1 if life_stage in str(product['가입대상고객_조건']) else 0
        join_amount_score = product['processed_가입금액'] / (total_amount + 1e-6)
        credit_score = 1 - delinquency_ratio
        return life_stage_match * 0.5 + join_amount_score * 0.3 + credit_score * 0.2

    filtered_products['매칭점수'] = filtered_products.apply(calculate_score, axis=1)

    # Step 4: 상위 N개 상품 추천
    recommended_products = filtered_products.nlargest(top_n, '매칭점수')[['상품명', '매칭점수']]

    return recommended_products

# 예제 회원 정보 입력
new_member = {
    "Life_Stage": 2,      # 가족형성기 (자녀 없음)
    "총이용금액": 1000000,  # 100만 원
    "연체비율": 0.05        # 5%
}

def recommend_products_unique(member_info, products, top_n=5):
    # Step 1: 회원 정보 추출
    life_stage = str(member_info['Life_Stage'])
    total_amount = float(member_info['총이용금액'])
    delinquency_ratio = float(member_info['연체비율'])

    # Step 2: 상품 데이터 필터링
    filtered_products = products[products['가입대상고객_조건'].str.contains(life_stage, na=False)]

    # Step 3: 매칭 점수 계산
    def calculate_score(product):
        life_stage_match = 1 if life_stage in str(product['가입대상고객_조건']) else 0
        join_amount_score = product['processed_가입금액'] / (total_amount + 1e-6)
        credit_score = 1 - delinquency_ratio
        return life_stage_match * 0.5 + join_amount_score * 0.3 + credit_score * 0.2

    filtered_products['매칭점수'] = filtered_products.apply(calculate_score, axis=1)

    # Step 4: 상위 N개 상품 추천 (중복 제거)
    recommended_products = (
        filtered_products.nlargest(top_n, '매칭점수')[['상품명', '매칭점수']]
        .drop_duplicates(subset='상품명')  # 중복 제거
    )

    return recommended_products

# 수정된 추천 알고리즘 실행
recommended_unique = recommend_products_unique(new_member, df_상품)
print(recommended_unique)

import re
import pandas as pd

# Life_Stage 매핑
life_stage_mapping = {
    1: "청년",
    2: "가족형성기",
    3: "자녀출산기",
    4: "자녀성장기",
    5: "자녀성장기",
    6: "자녀출가기",
    7: "노령"
}

# 가입금액 전처리 함수
def process_join_amount(value, avg_amount=1000000):
    try:
        if pd.isna(value) or "제한없음" in value or "0원" in value:
            return avg_amount
        if isinstance(value, str) and "~" in value:
            match = re.search(r"(\d+)[억|천|백|만원]*", value.split("~")[0])
            if match:
                return convert_to_numeric(match.group(1))
        if isinstance(value, str):
            match = re.search(r"(\d+)[억|천|백|만원]*", value)
            if match:
                return convert_to_numeric(match.group(1))
        return float(value)
    except Exception as e:
        print(f"Error processing value '{value}': {e}")
        return avg_amount

def convert_to_numeric(value):
    if "억" in value:
        return float(value.replace("억", "").strip()) * 100000000
    if "천" in value:
        return float(value.replace("천", "").strip()) * 1000
    if "백" in value:
        return float(value.replace("백", "").strip()) * 100
    if "만원" in value:
        return float(value.replace("만원", "").strip()) * 10000
    return float(value)

# 필터링 함수
def filter_products(member_info, products, life_stage_mapping):
    def is_valid_product(product):
        # 상품 조건 문자열 정규화
        product_condition = str(product['가입대상고객_조건']).replace("\n", "").replace(" ", "").strip()
        product_name = str(product['상품명']).replace("\n", "").replace(" ", "").strip()
        member_age = member_info['age']

        # 군적금 상품 필터링
        if "군" in product_name or "군적금" in product_name:
            print(f"제외된 군적금 상품: {product['상품명']} (나이: {member_age})")
            return False

        # 청년/청춘/청년 우대형 관련 상품 필터링
        if member_age > 34:  # 나이가 34세 초과일 경우
            if "청년" in product_condition or "청춘" in product_condition or "청년우대형" in product_name or "청춘희망적금" in product_name:
                print(f"제외된 청년/청춘 상품: {product['상품명']} (나이: {member_age})")
                return False

        # 일반 Life Stage 매칭
        life_stage_num = str(member_info['Life_Stage'])
        life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
        if life_stage_num in product_condition or life_stage_keyword in product_condition:
            return True

        # 연령 범위 필터링
        age_range = re.search(r"만(\d+)세~만(\d+)세", product_condition)
        if age_range:
            min_age, max_age = map(int, age_range.groups())
            if min_age <= member_age <= max_age:
                return True

        return False

    # 필터링 적용
    filtered_products = products[products.apply(is_valid_product, axis=1)]
    print(f"필터링 후 남은 상품 수: {len(filtered_products)}")  # 디버깅용 출력
    return filtered_products

# 매칭 점수 계산 함수
def calculate_score(member_info, product, weight_factors, preferred_duration="12개월 이상 ~ 24개월 미만"):
    life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
    life_stage_match = 1 if (
        str(member_info['Life_Stage']) in str(product['가입대상고객_조건']) or
        life_stage_keyword in str(product['가입대상고객_조건'])
    ) else 0

    join_amount_score = min(product['processed_가입금액'] / (member_info['총이용금액'] + 1e-6), 0.5)
    credit_score = max(0.1, 1 - member_info['연체비율'])
    duration_match = 1 if preferred_duration in str(product['계약기간']) else 0

    total_score = (
        life_stage_match * weight_factors['life_stage'] +
        join_amount_score * weight_factors['join_amount'] +
        credit_score * weight_factors['delinquency'] +
        duration_match * weight_factors['preferred_duration']
    )
    return total_score

# 추천 알고리즘
def recommend_products(member_info, products, weight_factors, top_n=5, randomize=False):
    # 가입금액 전처리
    valid_amounts = products['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
    avg_amount = valid_amounts.mean()
    products['processed_가입금액'] = products['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

    # 필터링 적용
    filtered_products = filter_products(member_info, products, life_stage_mapping)

    # 매칭 점수 계산
    preferred_duration = member_info.get('선호계약기간', "12개월 이상 ~ 24개월 미만")
    filtered_products['매칭점수'] = filtered_products.apply(
        lambda product: calculate_score(member_info, product, weight_factors, preferred_duration), axis=1
    )

    if randomize:
        filtered_products = filtered_products.sample(frac=1)

    # 추천 결과 반환
    recommended_products = (
        filtered_products.nlargest(top_n, '매칭점수')
        .drop_duplicates(subset='상품명')[['상품명', '매칭점수']]
    )

    return recommended_products

# 가중치 설정
weight_factors = {
    "life_stage": 0.4,
    "join_amount": 0.3,
    "delinquency": 0.2,
    "preferred_duration": 0.1
}

# 회원 정보
new_member = {
    "Life_Stage": 1,
    "age": 37,
    "총이용금액": 100000,
    "연체비율": 0.05,
    "선호계약기간": "12개월 이상 ~ 24개월 미만"
}

# 상품 데이터 준비
valid_amounts = df_상품['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
avg_amount = valid_amounts.mean()
df_상품['processed_가입금액'] = df_상품['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

# 추천 실행
recommended = recommend_products(new_member, df_상품, weight_factors, top_n=5, randomize=True)

# 결과 출력
print("최종 추천된 상품:")
print(recommended)

import random
import pandas as pd
import re

# Life_Stage 매핑
life_stage_mapping = {
    1: "청년",
    2: "가족형성기",
    3: "자녀출산기",
    4: "자녀성장기",
    5: "자녀출가기",
    6: "노령"
}

# 가입금액 전처리 함수
def process_join_amount(value, avg_amount=1000000):
    try:
        if pd.isna(value) or "제한없음" in value or "0원" in value:
            return avg_amount
        if isinstance(value, str) and "~" in value:
            match = re.search(r"(\d+)[억|천|백|만원]*", value.split("~")[0])
            if match:
                return convert_to_numeric(match.group(1))
        if isinstance(value, str):
            match = re.search(r"(\d+)[억|천|백|만원]*", value)
            if match:
                return convert_to_numeric(match.group(1))
        return float(value)
    except Exception as e:
        print(f"Error processing value '{value}': {e}")
        return avg_amount

def convert_to_numeric(value):
    if "억" in value:
        return float(value.replace("억", "").strip()) * 100000000
    if "천" in value:
        return float(value.replace("천", "").strip()) * 1000
    if "백" in value:
        return float(value.replace("백", "").strip()) * 100
    if "만원" in value:
        return float(value.replace("만원", "").strip()) * 10000
    return float(value)

# 필터링 함수
def filter_products(member_info, products, life_stage_mapping):
    def is_valid_product(product):
        product_condition = str(product['가입대상고객_조건']).replace("\n", "").replace(" ", "").strip()
        product_name = str(product['상품명']).replace("\n", "").replace(" ", "").strip()
        member_age = member_info['age']

        # 군적금 및 장병 상품 필터링
        if "군" in product_name or "군적금" in product_name or "장병" in product_name or "외국인" in product_name:
            print(f"제외된 군/장병 관련 상품: {product['상품명']} (나이: {member_age})")
            return False

        # 청년/청춘/청년 우대형 관련 상품 필터링
        if member_age > 34:  # 나이가 34세 초과일 경우
            if "청년" in product_condition or "청춘" in product_condition or "청년우대형" in product_name or "청춘" in product_name:
                print(f"제외된 청년/청춘 상품: {product['상품명']} (나이: {member_age})")
                return False

        # 일반 Life Stage 매칭
        life_stage_num = str(member_info['Life_Stage'])
        life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
        if life_stage_num in product_condition or life_stage_keyword in product_condition:
            return True

        # 연령 범위 필터링
        age_range = re.search(r"만(\d+)세~만(\d+)세", product_condition)
        if age_range:
            min_age, max_age = map(int, age_range.groups())
            if min_age <= member_age <= max_age:
                return True

        return False

    filtered_products = products[products.apply(is_valid_product, axis=1)]
    return filtered_products

# 매칭 점수 계산 함수
def calculate_score(member_info, product, weight_factors, preferred_duration="12개월 이상 ~ 24개월 미만"):
    life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
    life_stage_match = 1 if (
        str(member_info['Life_Stage']) in str(product['가입대상고객_조건']) or
        life_stage_keyword in str(product['가입대상고객_조건'])
    ) else 0

    join_amount_score = min(product['processed_가입금액'] / (member_info['총이용금액'] + 1e-6), 0.5)
    credit_score = max(0.1, 1 - member_info['연체비율'])
    duration_match = 1 if preferred_duration in str(product['계약기간']) else 0

    total_score = (
        life_stage_match * weight_factors['life_stage'] +
        join_amount_score * weight_factors['join_amount'] +
        credit_score * weight_factors['delinquency'] +
        duration_match * weight_factors['preferred_duration']
    )
    return total_score

# 추천 알고리즘
def recommend_products(member_info, products, weight_factors, top_n=5):
    # 가입금액 전처리
    valid_amounts = products['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
    avg_amount = valid_amounts.mean()
    products['processed_가입금액'] = products['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

    # 필터링 적용
    filtered_products = filter_products(member_info, products, life_stage_mapping)

    # 매칭 점수 계산
    preferred_duration = member_info.get('선호계약기간', "12개월 이상 ~ 24개월 미만")
    filtered_products['매칭점수'] = filtered_products.apply(
        lambda product: calculate_score(member_info, product, weight_factors, preferred_duration), axis=1
    )

    # 추천 결과 반환
    recommended_products = (
        filtered_products.nlargest(top_n, '매칭점수')
        .drop_duplicates(subset='상품명')[['상품명', '매칭점수']]
    )

    return recommended_products

# 랜덤 회원 정보 생성 함수
def generate_random_member(age_range, life_stage_options):
    age = random.randint(*age_range)
    life_stage = random.choice(life_stage_options)
    total_spent = random.randint(100000, 1000000)
    delinquency_ratio = random.uniform(0, 0.3)
    preferred_duration = random.choice(["6개월 이상 ~ 12개월 미만", "12개월 이상 ~ 24개월 미만", "24개월 이상"])
    return {
        "Life_Stage": life_stage,
        "age": age,
        "총이용금액": total_spent,
        "연체비율": delinquency_ratio,
        "선호계약기간": preferred_duration
    }

# 가중치 설정
weight_factors = {
    "life_stage": 0.4,
    "join_amount": 0.3,
    "delinquency": 0.2,
    "preferred_duration": 0.1
}

# 연령대별 랜덤 회원 정보 생성 및 추천
age_ranges = {
    "20대": ((20, 29), [1]),
    "30대": ((30, 39), [1, 2, 3]),
    "40대": ((40, 49), [1, 2, 3, 4]),
    "50대": ((50, 59), [4, 5, 6]),
    "60대": ((60, 69), [6])
}

for age_group, (age_range, life_stage_options) in age_ranges.items():
    random_member = generate_random_member(age_range, life_stage_options)
    print(f"\n{age_group} 추천 결과 (회원 정보: {random_member}):")
    recommended = recommend_products(random_member, df_상품, weight_factors, top_n=5)
    print(recommended)

import random
import pandas as pd
import re

# Life_Stage 매핑
life_stage_mapping = {
    1: "청년",
    2: "가족형성기",
    3: "자녀출산기",
    4: "자녀성장기",
    5: "자녀출가기",
    6: "노령"
}

# 가입금액 전처리 함수
def process_join_amount(value, avg_amount=1000000):
    try:
        if pd.isna(value) or "제한없음" in value or "0원" in value:
            return avg_amount
        if isinstance(value, str) and "~" in value:
            match = re.search(r"(\d+)[억|천|백|만원]*", value.split("~")[0])
            if match:
                return convert_to_numeric(match.group(1))
        if isinstance(value, str):
            match = re.search(r"(\d+)[억|천|백|만원]*", value)
            if match:
                return convert_to_numeric(match.group(1))
        return float(value)
    except Exception as e:
        print(f"Error processing value '{value}': {e}")
        return avg_amount

def convert_to_numeric(value):
    if "억" in value:
        return float(value.replace("억", "").strip()) * 100000000
    if "천" in value:
        return float(value.replace("천", "").strip()) * 1000
    if "백" in value:
        return float(value.replace("백", "").strip()) * 100
    if "만원" in value:
        return float(value.replace("만원", "").strip()) * 10000
    return float(value)

# 필터링 함수
def filter_products(member_info, products, life_stage_mapping):
    def is_valid_product(product):
        product_condition = str(product['가입대상고객_조건']).replace("\n", "").replace(" ", "").strip()
        product_name = str(product['상품명']).replace("\n", "").replace(" ", "").strip()
        member_age = member_info['age']

        # 군적금 및 장병 상품 필터링
        if "군" in product_name or "군적금" in product_name or "장병" in product_name:
            return False

        # 청년/청춘/청년 우대형 관련 상품 필터링
        if member_age > 34:  # 나이가 34세 초과일 경우
            if "청년" in product_condition or "청춘" in product_condition or "청년우대형" in product_name or "청춘희망적금" in product_name:
                return False

        # 50대 이상에서 적합하지 않은 상품 필터링
        if member_age >= 50:
            if "희망" in product_name or "도전" in product_name or "청년도약" in product_name:
                return False

        # 일반 Life Stage 매칭
        life_stage_num = str(member_info['Life_Stage'])
        life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
        if life_stage_num in product_condition or life_stage_keyword in product_condition:
            return True

        # 연령 범위 필터링
        age_range = re.search(r"만(\d+)세~만(\d+)세", product_condition)
        if age_range:
            min_age, max_age = map(int, age_range.groups())
            if min_age <= member_age <= max_age:
                return True

        return False

    filtered_products = products[products.apply(is_valid_product, axis=1)]
    return filtered_products

# 매칭 점수 계산 함수
def calculate_score(member_info, product, weight_factors, preferred_duration="12개월 이상 ~ 24개월 미만"):
    life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
    life_stage_match = 1 if (
        str(member_info['Life_Stage']) in str(product['가입대상고객_조건']) or
        life_stage_keyword in str(product['가입대상고객_조건'])
    ) else 0

    join_amount_score = min(product['processed_가입금액'] / (member_info['총이용금액'] + 1e-6), 0.5)
    credit_score = max(0.1, 1 - member_info['연체비율'])
    duration_match = 1 if preferred_duration in str(product['계약기간']) else 0

    total_score = (
        life_stage_match * weight_factors['life_stage'] +
        join_amount_score * weight_factors['join_amount'] +
        credit_score * weight_factors['delinquency'] +
        duration_match * weight_factors['preferred_duration']
    )
    return total_score

# 추천 알고리즘
def recommend_products(member_info, products, weight_factors, top_n=5):
    # 가입금액 전처리
    valid_amounts = products['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
    avg_amount = valid_amounts.mean()
    products['processed_가입금액'] = products['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

    # 필터링 적용
    filtered_products = filter_products(member_info, products, life_stage_mapping)

    # 매칭 점수 계산
    preferred_duration = member_info.get('선호계약기간', "12개월 이상 ~ 24개월 미만")
    filtered_products['매칭점수'] = filtered_products.apply(
        lambda product: calculate_score(member_info, product, weight_factors, preferred_duration), axis=1
    )

    # 추천 결과 반환
    recommended_products = (
        filtered_products.nlargest(top_n, '매칭점수')
        .drop_duplicates(subset='상품명')[['상품명', '매칭점수']]
    )

    return recommended_products

# 랜덤 회원 정보 생성 함수
def generate_random_member(age_range, life_stage_options):
    age = random.randint(*age_range)
    life_stage = random.choice(life_stage_options)
    total_spent = random.randint(100000, 1000000)
    delinquency_ratio = random.uniform(0, 0.3)
    preferred_duration = random.choice(["6개월 이상 ~ 12개월 미만", "12개월 이상 ~ 24개월 미만", "24개월 이상"])
    return {
        "Life_Stage": life_stage,
        "age": age,
        "총이용금액": total_spent,
        "연체비율": delinquency_ratio,
        "선호계약기간": preferred_duration
    }

# 가중치 설정
weight_factors = {
    "life_stage": 0.4,
    "join_amount": 0.3,
    "delinquency": 0.2,
    "preferred_duration": 0.1
}

# 연령대별 랜덤 회원 정보 생성 및 추천
age_ranges = {
    "20대": ((20, 29), [1]),
    "30대": ((30, 39), [1, 2, 3]),
    "40대": ((40, 49), [1, 2, 3, 4]),
    "50대": ((50, 59), [4, 5, 6]),
    "60대": ((60, 69), [6])
}

for age_group, (age_range, life_stage_options) in age_ranges.items():
    random_member = generate_random_member(age_range, life_stage_options)
    recommended = recommend_products(random_member, df_상품, weight_factors, top_n=5)
    print(f"\n{age_group} 추천 결과:")
    print(recommended)



from collections import Counter
import random
import pandas as pd
import re

# Life_Stage 매핑
life_stage_mapping = {
    1: "청년",
    2: "가족형성기",
    3: "자녀출산기",
    4: "자녀성장기",
    5: "자녀출가기",
    6: "노령"
}

# 기존 함수들: process_join_amount, convert_to_numeric, filter_products, calculate_score, recommend_products 유지

# 랜덤 회원 정보 생성 함수
def generate_random_member(age_range, life_stage_options):
    age = random.randint(*age_range)
    life_stage = random.choice(life_stage_options)
    total_spent = random.randint(100000, 1000000)
    delinquency_ratio = random.uniform(0, 0.3)
    preferred_duration = random.choice(["6개월 이상 ~ 12개월 미만", "12개월 이상 ~ 24개월 미만", "24개월 이상"])
    return {
        "Life_Stage": life_stage,
        "age": age,
        "총이용금액": total_spent,
        "연체비율": delinquency_ratio,
        "선호계약기간": preferred_duration
    }

# 추천 빈도 분석 함수
def analyze_recommendation_frequencies(products, weight_factors, iterations=100):
    age_ranges = {
        "20대": ((20, 29), [1]),
        "30대": ((30, 39), [1, 2, 3]),
        "40대": ((40, 49), [1, 2, 3, 4]),
        "50대": ((50, 59), [4, 5, 6]),
        "60대": ((60, 69), [6])
    }

    # 빈도 계산을 위한 초기화
    age_group_frequencies = {age_group: Counter() for age_group in age_ranges}

    # 각 연령대에서 반복 실행
    for age_group, (age_range, life_stage_options) in age_ranges.items():
        for _ in range(iterations):
            random_member = generate_random_member(age_range, life_stage_options)
            recommended = recommend_products(random_member, products, weight_factors, top_n=5)
            # 상품명 빈도 추가
            age_group_frequencies[age_group].update(recommended['상품명'])

    return age_group_frequencies

# 가중치 설정
weight_factors = {
    "life_stage": 0.4,
    "join_amount": 0.3,
    "delinquency": 0.2,
    "preferred_duration": 0.1
}

# 데이터 준비
valid_amounts = df_상품['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
avg_amount = valid_amounts.mean()
df_상품['processed_가입금액'] = df_상품['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

# 추천 빈도 분석 실행
iterations_per_age_group = 100  # 연령대별 랜덤 회원 수
age_group_frequencies = analyze_recommendation_frequencies(df_상품, weight_factors, iterations=iterations_per_age_group)

# 결과 출력
for age_group, frequencies in age_group_frequencies.items():
    print(f"\n{age_group} 추천 상품 빈도:")
    print(pd.DataFrame(frequencies.most_common(), columns=["상품명", "추천 횟수"]))

import matplotlib.pyplot as plt
import pandas as pd

# Data: Frequency results with English translations
frequency_data = {
    "20s": {
        "Product": ["My Home Plan Housing Subscription", "Shinhan Alsol Savings", "Youth Preferential Housing Savings",
                    "Hana Mi-Sodream Savings", "NH Green World Savings", "NH 1934 Monthly Compound Interest Savings",
                    "NH 1418 Swing Savings", "NH Foreigner Preferential Savings", "Woori Cube Fixed Deposit", "Youth Hope Savings"],
        "Frequency": [61, 61, 61, 61, 61, 39, 39, 39, 39, 39]
    },
    "30s": {
        "Product": ["Shinhan New Hope Savings", "NH 1934 Monthly Compound Interest Savings", "Youth Preferential Housing Savings",
                    "Faithful Taxpayer Preferential Savings (Individual)", "Faithful Taxpayer Preferential Savings (Corporate)",
                    "Youth Preferential Housing Savings", "Shinhan Alsol Savings", "My Home Plan Housing Subscription",
                    "Hana Mi-Sodream Savings", "NH Green World Savings", "Youth Hope Savings", "Sol Convenient Gift Savings",
                    "NH Youth Leap Account", "NH 1418 Swing Savings", "NH Foreigner Preferential Savings", "Woori Cube Fixed Deposit",
                    "NH Workplace Monthly Compound Interest Savings", "Youth Preferential Housing Savings", "KB Companion Happiness Savings",
                    "Shinhan Smart Savings", "Shinhan Youth Leap Account"],
        "Frequency": [58, 38, 36, 35, 35, 25, 19, 19, 19, 19, 15, 15, 15, 14, 14, 14, 12, 9, 9, 7, 4]
    },
    "40s": {
        "Product": ["Shinhan New Hope Savings", "NH 1934 Monthly Compound Interest Savings", "Sol Convenient Gift Savings",
                    "NH Youth Leap Account", "Faithful Taxpayer Preferential Savings (Individual)", "Faithful Taxpayer Preferential Savings (Corporate)",
                    "Challenge 365 Savings", "NH 1418 Swing Savings", "Shinhan Alsol Savings", "My Home Plan Housing Subscription",
                    "Hana Mi-Sodream Savings", "NH Green World Savings", "NH Workplace Monthly Compound Interest Savings", "KB Companion Happiness Savings",
                    "NH Foreigner Preferential Savings", "Woori Cube Fixed Deposit", "Shinhan Smart Savings"],
        "Frequency": [77, 56, 47, 40, 30, 30, 28, 16, 14, 14, 14, 14, 14, 13, 9, 9, 9]
    },
    "50s": {
        "Product": ["Shinhan Pension Savings King", "NH All-Won Mini Savings", "KB National Happiness Savings",
                    "Golden Age Savings (Pension Type)", "NH 1934 Monthly Compound Interest Savings", "NH 1418 Swing Savings",
                    "Sol Convenient Gift Savings", "Faithful Taxpayer Preferential Savings (Individual)",
                    "Faithful Taxpayer Preferential Savings (Corporate)", "First Salary Woori Savings"],
        "Frequency": [37, 37, 32, 32, 31, 31, 31, 25, 25, 12]
    },
    "60s": {
        "Product": ["KB National Happiness Savings", "Golden Age Savings (Pension Type)"],
        "Frequency": [100, 100]
    }
}

# Plotting
for age_group, data in frequency_data.items():
    df = pd.DataFrame(data)
    plt.figure(figsize=(12, 6))
    plt.bar(df["Product"], df["Frequency"], color='skyblue')
    plt.title(f"{age_group} Recommended Products Frequency", fontsize=16)
    plt.xlabel("Product", fontsize=14)
    plt.ylabel("Frequency", fontsize=14)
    plt.xticks(rotation=45, ha="right", fontsize=10)
    plt.tight_layout()
    plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# 연령별 총 이용금액 계산
age_usage = df_회원.groupby('연령')['총이용금액'].mean().reset_index()
age_usage.rename(columns={'총이용금액': 'Total Usage'}, inplace=True)

# 연령별 가입금액 계산 (예시: 가입금액 데이터를 연령별로 매핑한 경우)
age_signup = df_회원.groupby('연령').size().reset_index(name='Signup Amount')
age_signup['Signup Amount'] = df_상품['processed_가입금액'][:len(age_signup)]  # 데이터 매칭

# 데이터 병합
age_data = pd.merge(age_usage, age_signup, on='연령')

# 그래프 생성
x = np.arange(len(age_data['연령']))  # 연령 그룹에 대한 x 위치
width = 0.35  # 막대 폭

fig, ax = plt.subplots(figsize=(10, 6))

# 총 이용금액과 가입금액 막대그래프
bar1 = ax.bar(x - width/2, age_data['Total Usage'], width, label='Total Usage', color='skyblue')
bar2 = ax.bar(x + width/2, age_data['Signup Amount'], width, label='Signup Amount', color='orange')

# 축 및 제목 설정
ax.set_xlabel('Age Groups', fontsize=12)
ax.set_ylabel('Amount (in KRW)', fontsize=12)
ax.set_title('Comparison of Total Usage and Signup Amount by Age Group', fontsize=14)
ax.set_xticks(x)
ax.set_xticklabels(age_data['연령'])
ax.legend()

# 값 라벨 추가
for bar in bar1:
    yval = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:,.0f}', ha='center', va='bottom', fontsize=10)
for bar in bar2:
    yval = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:,.0f}', ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# 가입금액 평균 계산 (전체 상품의 평균)
average_signup_amount = df_상품['processed_가입금액'].mean()

# 연령별 총 이용금액 평균 계산
age_usage = df_회원.groupby('연령')['총이용금액'].mean().reset_index()
age_usage.rename(columns={'총이용금액': 'Total Usage (Average)'}, inplace=True)

# 각 연령별 총 이용금액이 가입금액 평균보다 낮은 인원 수 계산
df_회원['가입금액_평균'] = average_signup_amount
df_회원['이용금액_낮음'] = df_회원['총이용금액'] < df_회원['가입금액_평균']
low_usage_counts = df_회원.groupby('연령')['이용금액_낮음'].sum().reset_index()
low_usage_counts.rename(columns={'이용금액_낮음': 'Count Below Avg Signup'}, inplace=True)

# 그래프 생성: 총 이용금액 평균 vs 가입금액 평균
x = np.arange(len(age_usage['연령']))  # 연령 그룹에 대한 x 위치
width = 0.35  # 막대 폭

fig, ax1 = plt.subplots(figsize=(10, 6))

# 총 이용금액 평균과 가입금액 평균 막대그래프
bar1 = ax1.bar(x - width/2, age_usage['Total Usage (Average)'], width, label='Avg Total Usage', color='skyblue')
bar2 = ax1.bar(x + width/2, [average_signup_amount] * len(age_usage), width, label='Avg Signup Amount', color='orange')

# 축 및 제목 설정
ax1.set_xlabel('Age Groups', fontsize=12)
ax1.set_ylabel('Amount (in KRW)', fontsize=12)
ax1.set_title('Comparison of Avg Total Usage and Avg Signup Amount by Age Group', fontsize=14)
ax1.set_xticks(x)
ax1.set_xticklabels(age_usage['연령'])
ax1.legend()

# 값 라벨 추가
for bar in bar1:
    yval = bar.get_height()
    ax1.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:,.0f}', ha='center', va='bottom', fontsize=10)
for bar in bar2:
    yval = bar.get_height()
    ax1.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:,.0f}', ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

# 그래프 생성: 가입금액 평균보다 낮은 인원 수
fig, ax2 = plt.subplots(figsize=(10, 6))
plt.bar(low_usage_counts['연령'], low_usage_counts['Count Below Avg Signup'], color='lightcoral')
plt.title('Count of Individuals Below Avg Signup Amount by Age Group', fontsize=14)
plt.xlabel('Age Groups', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)

# 값 라벨 추가
for index, value in enumerate(low_usage_counts['Count Below Avg Signup']):
    plt.text(low_usage_counts['연령'][index], value, str(value), ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

import random
import pandas as pd
import re

# Life_Stage 매핑
life_stage_mapping = {
    1: "청년",
    2: "가족형성기",
    3: "자녀출산기",
    4: "자녀성장기",
    5: "자녀출가기",
    6: "노령"
}

# 가입금액 전처리 함수
def process_join_amount(value, avg_amount=1000000):
    try:
        if pd.isna(value) or "제한없음" in value or "0원" in value:
            return avg_amount
        if isinstance(value, str) and "~" in value:
            match = re.search(r"(\d+)[억|천|백|만원]*", value.split("~")[0])
            if match:
                return convert_to_numeric(match.group(1))
        if isinstance(value, str):
            match = re.search(r"(\d+)[억|천|백|만원]*", value)
            if match:
                return convert_to_numeric(match.group(1))
        return float(value)
    except Exception as e:
        print(f"Error processing value '{value}': {e}")
        return avg_amount

def convert_to_numeric(value):
    if "억" in value:
        return float(value.replace("억", "").strip()) * 100000000
    if "천" in value:
        return float(value.replace("천", "").strip()) * 1000
    if "백" in value:
        return float(value.replace("백", "").strip()) * 100
    if "만원" in value:
        return float(value.replace("만원", "").strip()) * 10000
    return float(value)

# 필터링 함수
def filter_products(member_info, products, life_stage_mapping):
    def is_valid_product(product):
        product_condition = str(product['가입대상고객_조건']).replace("\n", "").replace(" ", "").strip()
        product_name = str(product['상품명']).replace("\n", "").replace(" ", "").strip()
        member_age = member_info['age']

        # 군적금 및 장병 상품 필터링
        if "군" in product_name or "군적금" in product_name or "장병" in product_name:
            return False

        # 청년/청춘/청년 우대형 관련 상품 필터링
        if member_age > 34:  # 나이가 34세 초과일 경우
            if "청년" in product_condition or "청춘" in product_condition or "청년우대형" in product_name or "청춘희망적금" in product_name:
                return False

        # 50대 이상에서 적합하지 않은 상품 필터링
        if member_age >= 50:
            if "희망" in product_name or "도전" in product_name or "청년도약" in product_name:
                return False

        # 일반 Life Stage 매칭
        life_stage_num = str(member_info['Life_Stage'])
        life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
        if life_stage_num in product_condition or life_stage_keyword in product_condition:
            return True

        # 연령 범위 필터링
        age_range = re.search(r"만(\d+)세~만(\d+)세", product_condition)
        if age_range:
            min_age, max_age = map(int, age_range.groups())
            if min_age <= member_age <= max_age:
                return True

        return False

    filtered_products = products[products.apply(is_valid_product, axis=1)]
    return filtered_products

# 매칭 점수 계산 함수
def calculate_score(member_info, product, weight_factors, preferred_duration="12개월 이상 ~ 24개월 미만"):
    life_stage_keyword = life_stage_mapping.get(member_info['Life_Stage'], "")
    life_stage_match = 1 if (
        str(member_info['Life_Stage']) in str(product['가입대상고객_조건']) or
        life_stage_keyword in str(product['가입대상고객_조건'])
    ) else 0

    join_amount_score = min(product['processed_가입금액'] / (member_info['총이용금액'] + 1e-6), 0.5)
    credit_score = max(0.1, 1 - member_info['연체비율'])
    duration_match = 1 if preferred_duration in str(product['계약기간']) else 0

    total_score = (
        life_stage_match * weight_factors['life_stage'] +
        join_amount_score * weight_factors['join_amount'] +
        credit_score * weight_factors['delinquency'] +
        duration_match * weight_factors['preferred_duration']
    )
    return total_score

# 추천 알고리즘
def recommend_products(member_info, products, weight_factors, top_n=5):
    # 가입금액 전처리
    valid_amounts = products['가입금액'].apply(lambda x: process_join_amount(x, 1000000))
    avg_amount = valid_amounts.mean()
    products['processed_가입금액'] = products['가입금액'].apply(lambda x: process_join_amount(x, avg_amount))

    # 필터링 적용
    filtered_products = filter_products(member_info, products, life_stage_mapping)

    # 매칭 점수 계산
    preferred_duration = member_info.get('선호계약기간', "12개월 이상 ~ 24개월 미만")
    filtered_products['매칭점수'] = filtered_products.apply(
        lambda product: calculate_score(member_info, product, weight_factors, preferred_duration), axis=1
    )

    # 추천 결과 반환
    recommended_products = (
        filtered_products.nlargest(top_n, '매칭점수')
        .drop_duplicates(subset='상품명')[['상품명', '매칭점수']]
    )

    return recommended_products

# 가중치 설정
weight_factors = {
    "life_stage": 0.4,
    "join_amount": 0.3,
    "delinquency": 0.2,
    "preferred_duration": 0.1
}


for age_group, (age_range, life_stage_options) in age_ranges.items():
    random_member = generate_random_member(age_range, life_stage_options)
    recommended = recommend_products(random_member, df_상품, weight_factors, top_n=5)
    print(f"\n{age_group} 추천 결과:")
    print(recommended)